{
  "language": "Solidity",
  "sources": {
    "contracts/ABCToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n// pragma solidity ^0.7.6;\r\n\r\nimport \"./AddressUtils.sol\";\r\nimport \"./interfaces/IERC1820.sol\";\r\nimport \"./interfaces/IERC20.sol\";\r\nimport \"./interfaces/IERC777.sol\";\r\nimport \"./interfaces/IERC777Hooks.sol\";\r\n\r\nerror ABCToken__BurnFromNoOne();\r\nerror ABCToken__ERC777InterfaceNotImplemented();\r\nerror ABCToken__NotAuthorized();\r\nerror ABCToken__NotEnoughBalance();\r\nerror ABCToken__NotImplemented();\r\nerror ABCToken__RecipientRevert();\r\nerror ABCToken__SameHolderAndOperator();\r\nerror ABCToken__SendAmountNotDivisible();\r\nerror ABCToken__SendTokenToNoOne();\r\nerror ABCToken__NotEnoughAllowance();\r\n\r\n/// TODO: add ERC20 compatiple\r\ncontract ABCToken is ERC777Token, Token {\r\n    using AddressUtils for address;\r\n    uint256 internal _totalTokenSupply;\r\n    uint256 internal constant _GRANULARITY = 1;\r\n\r\n    mapping(address => uint256) internal _addressBalance;\r\n\r\n    // address internal immutable i_deployer;\r\n    // address[] holders;\r\n    mapping(address => mapping(address => bool))\r\n        internal _holderOperators;\r\n\r\n    mapping(address => mapping(address => uint256))\r\n        internal _holderOperatorsAllowance;\r\n\r\n    // TODO: CHANGE TO THE CORRECT ADDRESS BEFORE DEPLOY\r\n    IERC1820Registry internal constant _ERC1820_REGISTRY =\r\n        IERC1820Registry(\r\n            0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24\r\n        );\r\n\r\n    constructor() {\r\n        _addressBalance[msg.sender] = 101e18;\r\n        _totalTokenSupply = 101e18;\r\n    }\r\n\r\n    /// Get the name of the token\r\n    function name()\r\n        external\r\n        pure\r\n        override(ERC777Token, Token)\r\n        returns (string memory)\r\n    {\r\n        return \"Alphabet\";\r\n    }\r\n\r\n    /// Get the symbol of the token\r\n    function symbol()\r\n        external\r\n        pure\r\n        override(ERC777Token, Token)\r\n        returns (string memory)\r\n    {\r\n        return \"ABC\";\r\n    }\r\n\r\n    /// Get the total number of minted tokens.\r\n    function totalSupply()\r\n        external\r\n        view\r\n        override(ERC777Token, Token)\r\n        returns (uint256)\r\n    {\r\n        return _totalTokenSupply;\r\n    }\r\n\r\n    /// Get the balance of the account with address holder .\r\n    /// The balance MUST be zero ( 0 ) or higher.\r\n    function balanceOf(address holder)\r\n        external\r\n        view\r\n        override(ERC777Token, Token)\r\n        returns (uint256)\r\n    {\r\n        return _addressBalance[holder];\r\n    }\r\n\r\n    /// Get the smallest part of the token thatâ€™s not divisible.\r\n    function granularity()\r\n        external\r\n        pure\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _GRANULARITY;\r\n    }\r\n\r\n    /// Get the list of default operators as defined by the token contract.\r\n    function defaultOperators()\r\n        external\r\n        pure\r\n        override\r\n        returns (address[] memory)\r\n    {\r\n        address[] memory operators;\r\n        // operators[0] = msg.sender;\r\n        // operators[1] = i_deployer;\r\n        return operators;\r\n    }\r\n\r\n    /// Indicate whether the operator address is an operator of the holder address.\r\n    function isOperatorFor(address operator, address holder)\r\n        public\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        if (holder == operator) {\r\n            return true;\r\n        }\r\n\r\n        return _holderOperators[holder][operator];\r\n    }\r\n\r\n    /// Set a third party operator address as an operator of msg.sender to send and burn tokens on its behalf.\r\n    function authorizeOperator(address operator)\r\n        external\r\n        override\r\n    {\r\n        if (msg.sender == operator)\r\n            revert ABCToken__SameHolderAndOperator();\r\n\r\n        _holderOperators[msg.sender][operator] = true;\r\n        emit AuthorizedOperator(operator, msg.sender);\r\n    }\r\n\r\n    /// Remove the right of the operator address to be an operator for msg.sender and to send and burn tokens on its behalf.\r\n    function revokeOperator(address operator)\r\n        external\r\n        override\r\n    {\r\n        if (msg.sender == operator)\r\n            revert ABCToken__SameHolderAndOperator();\r\n\r\n        _holderOperators[msg.sender][operator] = false;\r\n        emit RevokedOperator(operator, msg.sender);\r\n    }\r\n\r\n    /// Send the 'amount' of tokens from the address 'msg.sender' to the address 'to' .\r\n    function send(\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external override {\r\n        operatorSend(\r\n            msg.sender,\r\n            to,\r\n            amount,\r\n            data,\r\n            bytes(\"\")\r\n        );\r\n    }\r\n\r\n    /// Send the 'amount' of tokens on behalf of the address 'from' to the address 'to'.\r\n    function operatorSend(\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory data,\r\n        bytes memory operatorData\r\n    ) public override {\r\n        // Simple first error check\r\n        _basicRevertCheck(from, amount);\r\n        if (to == address(0))\r\n            revert ABCToken__SendTokenToNoOne();\r\n\r\n        // recipient ERC777\r\n        address recipientImplementerAddress = _ERC1820_REGISTRY\r\n                .getInterfaceImplementer(\r\n                    to,\r\n                    keccak256(\"ERC777TokensRecipient\")\r\n                );\r\n\r\n        if (\r\n            to.isContract() &&\r\n            recipientImplementerAddress == address(0)\r\n        ) revert ABCToken__ERC777InterfaceNotImplemented();\r\n\r\n        // call holder ERC777 hook before changing state\r\n        _callTokenToSendHook(\r\n            msg.sender,\r\n            from,\r\n            to,\r\n            amount,\r\n            data,\r\n            operatorData\r\n        );\r\n\r\n        // Changing State\r\n        _addressBalance[from] -= amount;\r\n        _addressBalance[to] += amount;\r\n        if (!isOperatorFor(msg.sender, from)) {\r\n            _holderOperatorsAllowance[from][\r\n                msg.sender\r\n            ] -= amount;\r\n        }\r\n        // call recipient ERC777 hook after changing state.\r\n        // Revert if recipient revert.\r\n\r\n        if (recipientImplementerAddress != address(0)) {\r\n            try\r\n                IERC777Recipient(\r\n                    recipientImplementerAddress\r\n                ).tokensReceived(\r\n                        msg.sender,\r\n                        from,\r\n                        to,\r\n                        amount,\r\n                        data,\r\n                        operatorData\r\n                    )\r\n            {} catch {\r\n                _addressBalance[from] += amount;\r\n                _addressBalance[to] -= amount;\r\n                revert ABCToken__RecipientRevert();\r\n            }\r\n        }\r\n\r\n        emit Sent(\r\n            msg.sender,\r\n            from,\r\n            to,\r\n            amount,\r\n            data,\r\n            operatorData\r\n        );\r\n\r\n        emit Transfer(from, to, amount);\r\n    }\r\n\r\n    function burn(uint256 amount, bytes calldata data)\r\n        external\r\n        override\r\n    {\r\n        operatorBurn(msg.sender, amount, data, bytes(\"\"));\r\n    }\r\n\r\n    function operatorBurn(\r\n        address from,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes memory operatorData\r\n    ) public override {\r\n        _basicRevertCheck(from, amount);\r\n        if (from == address(0))\r\n            revert ABCToken__BurnFromNoOne();\r\n\r\n        _callTokenToSendHook(\r\n            msg.sender,\r\n            from,\r\n            address(0),\r\n            amount,\r\n            data,\r\n            operatorData\r\n        );\r\n\r\n        // State Change\r\n        _addressBalance[from] -= amount;\r\n        _totalTokenSupply -= amount;\r\n\r\n        emit Burned(\r\n            msg.sender,\r\n            from,\r\n            amount,\r\n            data,\r\n            operatorData\r\n        );\r\n\r\n        /// ERC20 Compatiple\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n\r\n    function _basicRevertCheck(address from, uint256 amount)\r\n        internal\r\n        view\r\n    {\r\n        if (\r\n            !isOperatorFor(msg.sender, from) &&\r\n            allowance(from, msg.sender) < amount\r\n        ) {\r\n            revert ABCToken__NotAuthorized();\r\n        }\r\n        if (amount % _GRANULARITY != 0)\r\n            revert ABCToken__SendAmountNotDivisible();\r\n        if (amount > _addressBalance[from])\r\n            revert ABCToken__NotEnoughBalance();\r\n    }\r\n\r\n    function _callTokenToSendHook(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory data,\r\n        bytes memory operatorData\r\n    ) internal {\r\n        address holderImplementerAddress = _ERC1820_REGISTRY\r\n            .getInterfaceImplementer(\r\n                from,\r\n                keccak256(\"ERC777TokensSender\")\r\n            );\r\n        if (holderImplementerAddress != address(0)) {\r\n            IERC777Sender(holderImplementerAddress)\r\n                .tokensToSend(\r\n                    operator,\r\n                    from,\r\n                    to,\r\n                    amount,\r\n                    data,\r\n                    operatorData\r\n                );\r\n        }\r\n    }\r\n\r\n    /// ERC20 Compatiple\r\n    function decimals() external pure returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount)\r\n        external\r\n        override\r\n        returns (bool success)\r\n    {\r\n        success = false;\r\n        operatorSend(\r\n            msg.sender,\r\n            to,\r\n            amount,\r\n            bytes(\"\"),\r\n            bytes(\"\")\r\n        );\r\n        success = true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external override returns (bool success) {\r\n        success = false;\r\n        operatorSend(\r\n            from,\r\n            to,\r\n            amount,\r\n            bytes(\"\"),\r\n            bytes(\"\")\r\n        );\r\n        success = true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value)\r\n        external\r\n        override\r\n        returns (bool success)\r\n    {\r\n        success = false;\r\n\r\n        _holderOperatorsAllowance[msg.sender][\r\n            _spender\r\n        ] = _value;\r\n\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        success = true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256 remaining)\r\n    {\r\n        remaining = _holderOperatorsAllowance[_owner][\r\n            _spender\r\n        ];\r\n    }\r\n}\r\n"
    },
    "contracts/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nlibrary AddressUtils {\r\n    function isContract(address _addr)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return (size > 0);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IERC1820.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/introspection/IERC1820Registry.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the global ERC1820 Registry, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\r\n * implementers for interfaces in this registry, as well as query support.\r\n *\r\n * Implementers may be shared by multiple accounts, and can also implement more\r\n * than a single interface for each account. Contracts can implement interfaces\r\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\r\n * contract.\r\n *\r\n * {IERC165} interfaces can also be queried via the registry.\r\n *\r\n * For an in-depth explanation and source code analysis, see the EIP text.\r\n */\r\ninterface IERC1820Registry {\r\n    event InterfaceImplementerSet(\r\n        address indexed account,\r\n        bytes32 indexed interfaceHash,\r\n        address indexed implementer\r\n    );\r\n\r\n    event ManagerChanged(address indexed account, address indexed newManager);\r\n\r\n    /**\r\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\r\n     * account is able to set interface implementers for it.\r\n     *\r\n     * By default, each account is its own manager. Passing a value of `0x0` in\r\n     * `newManager` will reset the manager to this initial state.\r\n     *\r\n     * Emits a {ManagerChanged} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `account`.\r\n     */\r\n    function setManager(address account, address newManager) external;\r\n\r\n    /**\r\n     * @dev Returns the manager for `account`.\r\n     *\r\n     * See {setManager}.\r\n     */\r\n    function getManager(address account) external view returns (address);\r\n\r\n    /**\r\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\r\n     * `interfaceHash`.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     * The zero address can also be used in `implementer` to remove an old one.\r\n     *\r\n     * See {interfaceHash} to learn how these are created.\r\n     *\r\n     * Emits an {InterfaceImplementerSet} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `account`.\r\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\r\n     * end in 28 zeroes).\r\n     * - `implementer` must implement {IERC1820Implementer} and return true when\r\n     * queried for support, unless `implementer` is the caller. See\r\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\r\n     */\r\n    function setInterfaceImplementer(\r\n        address account,\r\n        bytes32 _interfaceHash,\r\n        address implementer\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\r\n     * implementer is registered, returns the zero address.\r\n     *\r\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\r\n     * zeroes), `account` will be queried for support of it.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     */\r\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /**\r\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\r\n     * corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\r\n     */\r\n    function interfaceHash(string calldata interfaceName)\r\n        external\r\n        pure\r\n        returns (bytes32);\r\n\r\n    /**\r\n     * @notice Updates the cache with whether the contract implements an ERC165 interface or not.\r\n     * @param account Address of the contract for which to update the cache.\r\n     * @param interfaceId ERC165 interface for which to update the cache.\r\n     */\r\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\r\n\r\n    /**\r\n     * @notice Checks whether a contract implements an ERC165 interface or not.\r\n     * If the result is not cached a direct lookup on the contract address is performed.\r\n     * If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\r\n     * {updateERC165Cache} with the contract address.\r\n     * @param account Address of the contract to check.\r\n     * @param interfaceId ERC165 interface to check.\r\n     * @return True if `account` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165Interface(address account, bytes4 interfaceId)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * @notice Checks whether a contract implements an ERC165 interface or not without using or updating the cache.\r\n     * @param account Address of the contract to check.\r\n     * @param interfaceId ERC165 interface to check.\r\n     * @return True if `account` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165InterfaceNoCache(\r\n        address account,\r\n        bytes4 interfaceId\r\n    ) external view returns (bool);\r\n}\r\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// https://eips.ethereum.org/EIPS/eip-20\r\n// SPDX-License-Identifier: MIT\r\n// pragma solidity >=0.5.0 <0.8.0;\r\npragma solidity ^0.8.9;\r\n\r\ninterface Token {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return balance the balance\r\n    function balanceOf(address _owner)\r\n        external\r\n        view\r\n        returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return success Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value)\r\n        external\r\n        returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return success Whether the transfer was successful or not\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return success Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value)\r\n        external\r\n        returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return remaining Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender)\r\n        external\r\n        view\r\n        returns (uint256 remaining);\r\n\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _value\r\n    );\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _value\r\n    );\r\n}\r\n"
    },
    "contracts/interfaces/IERC777.sol": {
      "content": "// https://eips.ethereum.org/EIPS/eip-777\r\n// Example implementation https://github.com/0xjac/ERC777/blob/master/contracts/examples/ReferenceToken.sol\r\n// SPDX-License-Identifier: MIT\r\n// pragma solidity >=0.5.0 <0.8.0;\r\npragma solidity ^0.8.9;\r\n\r\ninterface ERC777Token {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address holder) external view returns (uint256);\r\n\r\n    function granularity() external view returns (uint256);\r\n\r\n    function defaultOperators() external view returns (address[] memory);\r\n\r\n    function isOperatorFor(address operator, address holder)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function authorizeOperator(address operator) external;\r\n\r\n    function revokeOperator(address operator) external;\r\n\r\n    function send(\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function operatorSend(\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    function burn(uint256 amount, bytes calldata data) external;\r\n\r\n    function operatorBurn(\r\n        address from,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    event Sent(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount,\r\n        bytes data,\r\n        bytes operatorData\r\n    );\r\n    event Minted(\r\n        address indexed operator,\r\n        address indexed to,\r\n        uint256 amount,\r\n        bytes data,\r\n        bytes operatorData\r\n    );\r\n    event Burned(\r\n        address indexed operator,\r\n        address indexed from,\r\n        uint256 amount,\r\n        bytes data,\r\n        bytes operatorData\r\n    );\r\n    event AuthorizedOperator(address indexed operator, address indexed holder);\r\n    event RevokedOperator(address indexed operator, address indexed holder);\r\n}\r\n"
    },
    "contracts/interfaces/IERC777Hooks.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\n/**\r\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\r\n *\r\n * {IERC777} Token holders can be notified of operations performed on their\r\n * tokens by having a contract implement this interface (contract holders can be\r\n * their own implementer) and registering it on the\r\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\r\n *\r\n * See {IERC1820Registry} and {ERC1820Implementer}.\r\n *\r\n * OpenZeppelin Contracts v4.4.1 (token/ERC777/IERC777Sender.sol)\r\n */\r\ninterface IERC777Sender {\r\n    /**\r\n     * @dev Called by an {IERC777} token contract whenever a registered holder's\r\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\r\n     * is conveyed by `to` being the zero address or not.\r\n     *\r\n     * This call occurs _before_ the token contract's state is updated, so\r\n     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\r\n     *\r\n     * This function may revert to prevent the operation from being executed.\r\n     */\r\n    function tokensToSend(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\r\n *\r\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\r\n * contract implement this interface (contract holders can be their own\r\n * implementer) and registering it on the\r\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\r\n *\r\n * See {IERC1820Registry} and {ERC1820Implementer}.\r\n * OpenZeppelin Contracts v4.4.1 (token/ERC777/IERC777Recipient.sol)\r\n *\r\n */\r\ninterface IERC777Recipient {\r\n    /**\r\n     * @dev Called by an {IERC777} token contract whenever tokens are being\r\n     * moved or created into a registered account (`to`). The type of operation\r\n     * is conveyed by `from` being the zero address or not.\r\n     *\r\n     * This call occurs _after_ the token contract's state is updated, so\r\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\r\n     *\r\n     * This function may revert to prevent the operation from being executed.\r\n     */\r\n    function tokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}